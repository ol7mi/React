{"ast":null,"code":"import \"./App.css\";\nimport { useState } from 'react';\n\n// function App() {\n//   //모든 UI 는 상태에서 파생된다\n//   let count = 1;\n\n//   function plus(){\n//     count++;\n//     document.getElementById(\"counter\").innerHTML = count;\n//     console.log(count);\n//   }\n//   function minus (){\n//     count--;\n//     document.getElementById(\"counter\").innerHTML = count;\n//     console.log(count);\n//   }\n\n//   return (\n//     <div className=\"App\">\n//       <div id=\"counter\">{count}</div>\n//       <hr></hr>\n//       <button id=\"plus\" onClick={plus}>+</button>\n//       <button id=\"minus\" onClick={minus}>-</button>\n//     </div>\n//   );\n\n// }\n\n// let count2 = 10; //함수가 다시 호출될 때 새로 선언됨 \n// function App() {\n//   // 상태변수 생성 (상태변수로 UI 가 변경되어야 함) \n//   // 한 번 선언되면 다시 선언되지 않음 -> 리렌더링에 의해서는 다시 선언되지 않음 \n//   //컴포넌트가 unmount 될 때는 초기화 됨 \n//   const [count, setCounter] = useState(1); \n//   const handlePlus = () => { //반드시 setter 를 통해서 값을 변경해야 한다 count++ 이런거 안된다 \n//     setCounter(count + 1);\n//     count2++;\n//   }\n//   const handleMinus = () => {\n//     setCounter(count - 1);\n//     count2--;\n//   }\n\n//   return (\n//     <div className=\"App\">\n//       <div>{count2} , {count}</div>\n//       <hr></hr>\n//       <button onClick={handlePlus}>+</button>\n//       <button onClick={handleMinus}>-</button>\n//     </div>\n//   );\n// }\n\n// function App(){\n//   const [str, setStr] = useState('기본 메세지');\n//   const hendleChange = (e) => { //입력된 걸 e 로 꺼내옴 \n//     setStr(e.target.value);\n//   }\n\n//   return (\n//     <div>\n\n//       <h1>{str}</h1>\n\n//       <hr/>\n\n//       <div>\n//         <input type=\"text\" onChange={hendleChange}></input>\n//         <button onClick={()=>{alert(str)}}> PopUp! </button>\n//       </div>\n\n//     </div>\n//   )\n// }\n\n// function App (){\n//   const [msg, setMsg] = useState([\"Hello\",\"React\",\"State\"]); //문자열 목록 상태 저장 \n//   const [msgs, setMsgs] = useState(''); //문자열 하나의 입력 상태 값 \n//   const handelChange = (e) => {\n//     setMsgs(e.target.value)\n//   }\n//   const handelSave = () => {\n//     //spread 연산자 ...배열 ...객체 \n//     setMsg((prev)=>{\n//       console.log(prev);\n//       //return 한 값이 세팅이 됨\n//       return [...prev, msgs]; //이전 데이터를 풀어놓고 . 새데이터를 넣어줌 \n//       setMsgs('');\n//     })\n//   }\n\n//   return (\n//     <div>\n//       <ul>\n//         {\n//           msg.map((message,index)=>{\n//             return (\n//               <li key={index}>{message}</li>\n//             );\n//           })\n//         }\n//       </ul>\n//       <hr></hr>\n//       <input type=\"text\" onChange={handelChange} value={msgs}></input>\n//       <button onClick={handelSave}>Save</button>\n//     </div>\n//   )\n// }\n\nexport default App;","map":{"version":3,"names":["useState","App"],"sources":["/Users/eungmi/Desktop/workspace/08_workspace_react/study03/src/App.js"],"sourcesContent":["import \"./App.css\";\nimport { useState } from 'react';\n\n\n\n// function App() {\n//   //모든 UI 는 상태에서 파생된다\n//   let count = 1;\n\n//   function plus(){\n//     count++;\n//     document.getElementById(\"counter\").innerHTML = count;\n//     console.log(count);\n//   }\n//   function minus (){\n//     count--;\n//     document.getElementById(\"counter\").innerHTML = count;\n//     console.log(count);\n//   }\n\n//   return (\n//     <div className=\"App\">\n//       <div id=\"counter\">{count}</div>\n//       <hr></hr>\n//       <button id=\"plus\" onClick={plus}>+</button>\n//       <button id=\"minus\" onClick={minus}>-</button>\n//     </div>\n//   );\n\n// }\n\n// let count2 = 10; //함수가 다시 호출될 때 새로 선언됨 \n// function App() {\n//   // 상태변수 생성 (상태변수로 UI 가 변경되어야 함) \n//   // 한 번 선언되면 다시 선언되지 않음 -> 리렌더링에 의해서는 다시 선언되지 않음 \n//   //컴포넌트가 unmount 될 때는 초기화 됨 \n//   const [count, setCounter] = useState(1); \n//   const handlePlus = () => { //반드시 setter 를 통해서 값을 변경해야 한다 count++ 이런거 안된다 \n//     setCounter(count + 1);\n//     count2++;\n//   }\n//   const handleMinus = () => {\n//     setCounter(count - 1);\n//     count2--;\n//   }\n\n//   return (\n//     <div className=\"App\">\n//       <div>{count2} , {count}</div>\n//       <hr></hr>\n//       <button onClick={handlePlus}>+</button>\n//       <button onClick={handleMinus}>-</button>\n//     </div>\n//   );\n// }\n\n// function App(){\n//   const [str, setStr] = useState('기본 메세지');\n//   const hendleChange = (e) => { //입력된 걸 e 로 꺼내옴 \n//     setStr(e.target.value);\n//   }\n\n//   return (\n//     <div>\n\n//       <h1>{str}</h1>\n\n//       <hr/>\n\n//       <div>\n//         <input type=\"text\" onChange={hendleChange}></input>\n//         <button onClick={()=>{alert(str)}}> PopUp! </button>\n//       </div>\n\n//     </div>\n//   )\n// }\n\n\n// function App (){\n//   const [msg, setMsg] = useState([\"Hello\",\"React\",\"State\"]); //문자열 목록 상태 저장 \n//   const [msgs, setMsgs] = useState(''); //문자열 하나의 입력 상태 값 \n//   const handelChange = (e) => {\n//     setMsgs(e.target.value)\n//   }\n//   const handelSave = () => {\n//     //spread 연산자 ...배열 ...객체 \n//     setMsg((prev)=>{\n//       console.log(prev);\n//       //return 한 값이 세팅이 됨\n//       return [...prev, msgs]; //이전 데이터를 풀어놓고 . 새데이터를 넣어줌 \n//       setMsgs('');\n//     })\n//   }\n\n//   return (\n//     <div>\n//       <ul>\n//         {\n//           msg.map((message,index)=>{\n//             return (\n//               <li key={index}>{message}</li>\n//             );\n//           })\n//         }\n//       </ul>\n//       <hr></hr>\n//       <input type=\"text\" onChange={handelChange} value={msgs}></input>\n//       <button onClick={handelSave}>Save</button>\n//     </div>\n//   )\n// }\n\nexport default App;\n"],"mappings":"AAAA,OAAO,WAAW;AAClB,SAASA,QAAQ,QAAQ,OAAO;;AAIhC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeC,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}